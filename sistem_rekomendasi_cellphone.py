# -*- coding: utf-8 -*-
"""sistem_rekomendasi_cellphone.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sB-oxdBNtb-8eoPzPpxzMnc-edSKyWUJ

# Import Library
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from tensorflow.keras.callbacks import EarlyStopping

"""# Load Dataset"""

from google.colab import files
files.upload()

!pip install -q kaggle
!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

!kaggle datasets download -d meirnizri/cellphones-recommendations
!unzip -q cellphones-recommendations.zip

# Load dataset
df_phones = pd.read_csv('cellphones data.csv')
df_ratings = pd.read_csv('cellphones ratings.csv')
df_users = pd.read_csv('cellphones users.csv')

"""# Data Understanding"""

df_phones.info()

"""* Total data: 33 baris, 14 kolom
* Tidak ada data yang hilang (semua kolom lengkap)
* Tipe data:

  * Numerik: 10 kolom (8 `int64`, 2 `float64`)
  * Kategorikal: 4 kolom (`object`)

"""

df_phones.head()

df_ratings.info()

"""* Total data: 990 baris, 3 kolom
* Tidak ada data yang hilang (semua kolom lengkap)
* Tipe data:

  * Numerik: 3 kolom (`int64`)

"""

df_ratings.describe()

"""* Total data: 990 baris
* Rating rata-rata: 6.7
* Rating min–maks: 1 hingga 18
* Rating median: 7
* Sebagian besar rating berada di rentang 5–9
* `user_id`: tersebar dari 0–258
* `cellphone_id`: mencakup 33 ponsel (ID 0–32)
"""

df_users.info()

"""* Total data: 99 baris, 4 kolom
* Terdapat 1 nilai hilang pada kolom `occupation`
* Tipe data:

  * Numerik: 2 kolom (`int64`)
  * Kategorikal: 2 kolom (`object`)
"""

df_users.head()

# Release date dalam format datetime
df_phones['release date'] = pd.to_datetime(df_phones['release date'], errors='coerce', dayfirst=True)
df_phones['release_year'] = df_phones['release date'].dt.year

# Frame 1: 6 Visualisasi
plt.figure(figsize=(20, 16))

# 1. Merek
plt.subplot(3, 2, 1)
sns.countplot(data=df_phones, x='brand')
plt.title('Jumlah Ponsel per Merek')
plt.xticks(rotation=45)

# 2. Sistem Operasi
plt.subplot(3, 2, 2)
sns.countplot(data=df_phones, x='operating system')
plt.title('Distribusi Sistem Operasi')
plt.xticks(rotation=45)

# 3. RAM
plt.subplot(3, 2, 3)
sns.countplot(data=df_phones, x='RAM')
plt.title('Distribusi RAM')
plt.xticks(rotation=45)

# 4. Memori Internal
plt.subplot(3, 2, 4)
sns.countplot(data=df_phones, x='internal memory')
plt.title('Distribusi Memori Internal')
plt.xticks(rotation=45)

# 5. Kamera Utama
plt.subplot(3, 2, 5)
sns.countplot(data=df_phones, x='main camera')
plt.title('Distribusi Kamera Utama')
plt.xticks(rotation=45)

# 6. Kamera Selfie
plt.subplot(3, 2, 6)
sns.countplot(data=df_phones, x='selfie camera')
plt.title('Distribusi Kamera Selfie')
plt.xticks(rotation=45)

plt.tight_layout()
plt.show()

# Frame 2: 4 Visualisasi
plt.figure(figsize=(20, 10))

# 7. Kapasitas Baterai
plt.subplot(2, 2, 1)
sns.countplot(data=df_phones, x='battery size')
plt.title('Distribusi Kapasitas Baterai')
plt.xticks(rotation=45)

# 8. Ukuran Layar
plt.subplot(2, 2, 2)
sns.countplot(data=df_phones, x='screen size')
plt.title('Distribusi Ukuran Layar')
plt.xticks(rotation=45)

# 9. Berat
plt.subplot(2, 2, 3)
sns.countplot(data=df_phones, x='weight')
plt.title('Distribusi Berat Ponsel')
plt.xticks(rotation=45)

# 10. Tahun Rilis
plt.subplot(2, 2, 4)
sns.countplot(data=df_phones, x='release_year')
plt.title('Distribusi Tahun Rilis')
plt.xticks(rotation=45)

plt.tight_layout()
plt.show()

"""* **Jumlah Ponsel per Merek**

  * Samsung mendominasi dengan jumlah ponsel terbanyak.
  * Diikuti oleh Apple dan Xiaomi.
  * Merek dengan jumlah ponsel paling sedikit adalah Asus, Sony, dan Vivo.

* **Sistem Operasi**

  * Mayoritas ponsel menggunakan **Android**.
  * Hanya sebagian kecil yang menggunakan **iOS** (khusus Apple).

* **RAM**

  * Ponsel dengan **RAM 6GB** paling umum ditemukan.
  * Diikuti oleh 4GB dan 8GB.
  * RAM 3GB dan 12GB hanya dimiliki sedikit ponsel.

* **Memori Internal**

  * Kapasitas **128GB** merupakan yang paling banyak digunakan.
  * Diikuti oleh 256GB, sedangkan kapasitas 512GB dan 64GB sangat jarang.

* **Kamera Utama**

  * Kamera 48MP paling banyak ditemukan.
  * Kamera 12MP juga cukup umum.
  * Kamera dengan resolusi sangat tinggi seperti 64MP dan 108MP hanya ada pada beberapa ponsel.

* **Kamera Selfie**

  * Resolusi kamera selfie sangat bervariasi.
  * Resolusi 20MP paling banyak ditemukan, disusul oleh 13MP dan 11MP.
  * Beberapa ponsel memiliki kamera selfie di bawah 10MP, namun jumlahnya lebih sedikit.
"""

# Visualisasi distribusi rating
plt.figure(figsize=(15, 5))

# 1. Distribusi nilai rating
plt.subplot(1, 2, 1)
sns.countplot(data=df_ratings, x='rating')
plt.title('Distribusi Nilai Rating')
plt.xlabel('Rating')
plt.ylabel('Jumlah')

# 2. Jumlah rating per ponsel (cellphone_id)
plt.subplot(1, 2, 2)
sns.countplot(data=df_ratings, x=df_ratings['cellphone_id'])
plt.title('Jumlah Rating per Ponsel')
plt.xlabel('ID Ponsel')
plt.ylabel('Jumlah')
plt.xticks(rotation=90)

plt.tight_layout()
plt.show()

"""* **Distribusi nilai rating**:

  * Rating paling umum: 8, diikuti oleh 7, 9, dan 10.
  * Sebagian besar pengguna memberi rating antara 6–10.
  * Terdapat outlier pada rating 18 (kemungkinan data salah input).

* **Jumlah rating per ponsel**:

  * Setiap ponsel mendapat jumlah rating yang cukup merata (sekitar 20–42 rating).
  * Ponsel dengan ID 30 memiliki jumlah rating terbanyak.
"""

# Visualisasi karakteristik pengguna
plt.figure(figsize=(20, 10))

# Usia
plt.subplot(1, 3, 1)
sns.countplot(data=df_users, x='age')
plt.title('Distribusi Usia Pengguna')
plt.xticks(rotation=90)

# Gender
plt.subplot(1, 3, 2)
sns.countplot(data=df_users, x='gender')
plt.title('Distribusi Gender Pengguna')

# Pekerjaan
plt.subplot(1, 3, 3)
sns.countplot(data=df_users, y='occupation', order=df_users['occupation'].value_counts().index)
plt.title('Distribusi Pekerjaan Pengguna')

plt.tight_layout()
plt.show()

"""* **Distribusi Usia**

  * Rentang usia pengguna paling banyak berada di **21–31 tahun**, dengan puncaknya pada usia **25 tahun**.
  * Setelah usia 35 tahun, jumlah pengguna menurun secara signifikan.
  * Terdapat sebaran hingga usia 61 tahun, namun jumlahnya lebih kecil.

* **Distribusi Gender**

  * Komposisi gender cukup seimbang:

    * **Laki-laki** sedikit lebih banyak dari perempuan.
    * Ada sebagian kecil data dengan gender tidak terisi (`-Select Gender-`).

* **Distribusi Pekerjaan**

  * Pengguna terbanyak berasal dari bidang `IT` dan `teknologi informasi`:
  * Pekerjaan seperti `Information Technology`, `IT`, `software developer`, `Data analyst`, dan `System Administrator` mendominasi.
  * Beberapa pekerjaan di bidang manajerial juga muncul cukup sering: `Manager`, `SALES MANAGER`, `Administrative officer`.
  * Selain itu, ada keberagaman pekerjaan dari sektor **kesehatan, pendidikan, keuangan, retail, konstruksi**, hingga **homemaker**.
  * Pengguna berasal dari latar belakang pekerjaan yang beragam. Namun, terdapat beberapa **inkonsistensi** penulisan yang perlu dibersihkan, seperti:
    * Kesalahan penulisan seperti `healthare` yang seharusnya adalah `healthcare`.
    * Pekerjaan `information technology` dan `IT` dapat digabungkan karena merujuk pada bidang yang sama.

# Data Prepocessing
"""

# Menggabungkan data rating dengan data ponsel
ratings_data = pd.merge(df_ratings, df_phones, how='inner', on='cellphone_id')
full_data = pd.merge(ratings_data, df_users, how='inner', on='user_id')

full_data.head()

"""* Data rating digabung dengan data ponsel lewat `cellphone_id`, menghasilkan rating + detail ponsel.
* Lalu digabung dengan data user lewat `user_id`, membentuk data lengkap: rating + ponsel + user.
"""

# Memeriksa nilai kosong pada data
full_data.isnull().sum()

"""* Semua kolom lengkap, kecuali `occupation` yang memiliki 10 data kosong.

"""

# Menghapus baris dengan nilai kosong
full_data.dropna(inplace=True)
full_data.isnull().sum()

"""* Baris dengan nilai kosong telah dihapus.
* Semua kolom kini bersih dari missing value.
"""

# Menyaring hanya rating dengan nilai 5 ke bawah
full_data = full_data[full_data['rating'] <= 5]

"""* Data difilter untuk menyisakan rating ≤ 5.

"""

# Menstandarkan penulisan dan memperbaiki kesalahan pengetikan pada kolom occupation
full_data['occupation'] = full_data['occupation'].str.lower().replace({
    'healthare': 'healthcare',
    'it': 'information technology'
})

"""* Penulisan pada kolom `occupation` diubah menjadi huruf kecil.
* Kesalahan ejaan seperti `healthare` diperbaiki menjadi `healthcare`.
* Istilah `it` diseragamkan menjadi `information technology`.

"""

# Menyaring hanya nilai gender yang valid
valid_genders = ['Male', 'Female']
full_data = full_data[full_data['gender'].isin(valid_genders)]

"""* Data difilter untuk hanya menyertakan gender yang valid: `'Male'` dan `'Female'`.
* Baris dengan nilai gender di luar daftar tersebut dihapus dari dataset.

"""

from datetime import datetime

# Menambahkan informasi waktu preprocessing
full_data['timestamp'] = datetime.now()

"""* Kolom `timestamp` ditambahkan untuk mencatat waktu preprocessing dilakukan."""

# Menyalin data hasil preprocessing ke variabel baru
prepared_data = full_data.copy()
prepared_data

"""* Data hasil preprocessing disalin ke variabel baru `prepared_data` untuk keperluan selanjutnya.

# Data Preparation
"""

# Menghapus duplikat berdasarkan cellphone_id
finalized_data = prepared_data.drop_duplicates(subset='cellphone_id')

"""* Duplikat berdasarkan `cellphone_id` dihapus untuk memastikan tiap ponsel hanya muncul sekali.

"""

# Menggabungkan fitur teks penting untuk content-based filtering
finalized_data['combined_features'] = (
    finalized_data['brand'].astype(str) + " " +
    finalized_data['model'].astype(str) + " " +
    finalized_data['operating system'].astype(str)
)

"""* Fitur teks `combined_features` dibuat dengan menggabungkan `brand`, `model`, dan `operating system` sebagai representasi konten untuk model content-based filtering."""

# Menyimpan fitur yang dibutuhkan ke dalam df_content
df_content = finalized_data[['cellphone_id', 'brand', 'model', 'operating system', 'combined_features']].copy()
df_content

"""* Data `df_content` berisi fitur penting: `cellphone_id`, `brand`, `model`, `operating system`, dan `combined_features`.
* Dataset ini disiapkan khusus untuk digunakan pada content-based filtering.

# Content Based Filtering
"""

# TF-IDF dari combined_features
vectorizer = TfidfVectorizer()
tfidf_matrix = vectorizer.fit_transform(df_content['combined_features'])

"""* Menggunakan **TF-IDF** untuk mengubah `combined_features` menjadi representasi numerik."""

# Menghitung similarity antar model
similarity_matrix = cosine_similarity(tfidf_matrix)

"""* Menghitung **kemiripan antar model** dengan `cosine_similarity`."""

# Membuat DataFrame similarity antar model
similarity_df = pd.DataFrame(
    similarity_matrix,
    index=df_content['model'],
    columns=df_content['model']
)

"""* Hasil similarity disimpan dalam `similarity_df`, berisi skor kesamaan antar model HP."""

# Fungsi rekomendasi berdasarkan similarity konten
def recommend_similar_models(target_model, similarity_data=similarity_df, items=df_content[['model', 'brand', 'operating system']], top_n=4):
    """
    Rekomendasi model HP mirip berdasarkan kemiripan konten (brand, model, OS).
    """
    if target_model not in similarity_data.columns:
        raise ValueError(f"Model '{target_model}' tidak ditemukan dalam data.")

    # Urutkan skor similarity tertinggi, selain diri sendiri
    scores = similarity_data[target_model].sort_values(ascending=False)
    recommended = scores.drop(labels=[target_model]).head(top_n).index

    # Ambil info model yang direkomendasikan
    return items[items['model'].isin(recommended)].reset_index(drop=True)

"""* Fungsi `recommend_similar_models()` dibuat untuk:

  * Mencari model dengan fitur konten paling mirip (brand, model, OS).
  * Mengembalikan daftar model rekomendasi teratas berdasarkan kemiripan konten.
"""

recommend_similar_models('iPhone 13')

"""**Rekomendasi untuk `iPhone 13`**

Model-model yang direkomendasikan semuanya berasal dari **brand dan sistem operasi yang sama (Apple, iOS)**, serta memiliki **kemiripan nama model**:

* **iPhone XR**, **iPhone 13 Mini**, **iPhone 13 Pro**, dan **iPhone 13 Pro Max** adalah bagian dari seri yang mirip, menandakan **konten fitur sangat serupa**.
* Ini menunjukkan bahwa pendekatan **content-based filtering** berhasil menangkap **kemiripan varian dalam satu lini produk**.
"""

recommend_similar_models('Galaxy A53')

"""**Rekomendasi untuk `Galaxy A53`**

Model-model yang direkomendasikan berasal dari **brand Samsung** dan menggunakan **sistem operasi Android**:

* Disarankan model dari berbagai seri seperti **A-series (A32)** dan **Z-series (Z Flip 3, Z Fold 3)** serta **S-series (S22)**.
* Ini menunjukkan bahwa meskipun model berbeda, pendekatan konten menangkap **kemiripan brand dan OS**, serta mungkin kata "Galaxy" dalam nama model.

# Collaborative Filtering
"""

# Salin data rating
df = df_ratings.copy()

# Encode user_id ke angka
user_ids = df['user_id'].unique().tolist()
user_to_user_encoded = {x: i for i, x in enumerate(user_ids)}
user_encoded_to_user = {i: x for i, x in enumerate(user_ids)}
df['user'] = df['user_id'].map(user_to_user_encoded)

# Encode cellphone_id ke angka
cellphone_ids = df['cellphone_id'].unique().tolist()
cellphone_to_cellphone_encoded = {x: i for i, x in enumerate(cellphone_ids)}
cellphone_encoded_to_cellphone = {i: x for i, x in enumerate(cellphone_ids)}
df['cellphone'] = df['cellphone_id'].map(cellphone_to_cellphone_encoded)

"""* **Encoding `user_id`**:

   * Membuat daftar unik `user_id`.
   * Menyusun mapping dari `user_id` asli ke angka urut (`user_to_user_encoded`).
   * Menyimpan mapping balik dari angka ke `user_id` asli (`user_encoded_to_user`).
   * Menambahkan kolom baru `user` berisi hasil encode.

* **Encoding `cellphone_id`**:

   * Hal serupa dilakukan untuk `cellphone_id`, menghasilkan kolom baru `cellphone`.

"""

# Menghapus rating tidak valid & konversi tipe
df = df[df['rating'] != 18]
df['rating'] = df['rating'].astype(np.float32)

# Normalisasi rating
min_rating, max_rating = df['rating'].min(), df['rating'].max()
df['rating_norm'] = df['rating'].apply(lambda x: (x - min_rating) / (max_rating - min_rating))

# Mengacak urutan data
df = df.sample(frac=1, random_state=42)

"""

* Menghapus rating tidak valid (rating = 18).
* Mengonversi rating ke tipe `float32` untuk efisiensi memori.
* Menormalisasi rating ke rentang \[0, 1] agar model lebih stabil.
* Mengacak urutan data untuk menghindari bias saat pelatihan."""

# Split data menjadi train dan validation
x = df[['user', 'cellphone']].values
y = df['rating_norm'].values
train_indices = int(0.8 * len(df))
x_train, x_val = x[:train_indices], x[train_indices:]
y_train, y_val = y[:train_indices], y[train_indices:]

"""

* Membagi data menjadi **80% data latih** dan **20% data validasi**.
* Fitur input: pasangan `user` dan `cellphone`.
* Target output: `rating_norm` (rating yang telah dinormalisasi).
"""

# Arsitektur Model RecommenderNet
class RecommenderNet(tf.keras.Model):
    def __init__(self, num_users, num_cellphones, embedding_size, **kwargs):
        super(RecommenderNet, self).__init__(**kwargs)
        self.user_embedding = layers.Embedding(
            input_dim=num_users,
            output_dim=embedding_size,
            embeddings_initializer='he_normal',
            embeddings_regularizer=keras.regularizers.l2(1e-4)
        )
        self.user_bias = layers.Embedding(num_users, 1)
        self.cellphone_embedding = layers.Embedding(
            input_dim=num_cellphones,
            output_dim=embedding_size,
            embeddings_initializer='he_normal',
            embeddings_regularizer=keras.regularizers.l2(1e-4)
        )
        self.cellphone_bias = layers.Embedding(num_cellphones, 1)

    def call(self, inputs):
        user_vector = self.user_embedding(inputs[:, 0])
        user_bias = self.user_bias(inputs[:, 0])
        cellphone_vector = self.cellphone_embedding(inputs[:, 1])
        cellphone_bias = self.cellphone_bias(inputs[:, 1])
        dot_product = tf.reduce_sum(user_vector * cellphone_vector, axis=1, keepdims=True)
        x = dot_product + user_bias + cellphone_bias
        return tf.nn.sigmoid(x)

"""* Model **RecommenderNet** mempelajari representasi pengguna dan ponsel dengan *embedding*, lalu menghitung prediksi rating melalui *dot product* ditambah bias. Output dinormalisasi dengan sigmoid agar berada di rentang \[0, 1].

"""

# Inisialisasi dan compile model
num_users = len(user_to_user_encoded)
num_cellphones = len(cellphone_to_cellphone_encoded)

model = RecommenderNet(num_users, num_cellphones, embedding_size=30)
model.compile(
    loss=tf.keras.losses.BinaryCrossentropy(),
    optimizer=keras.optimizers.Adam(learning_rate=0.001),
    metrics=[tf.keras.metrics.RootMeanSquaredError()]
)

"""

* **Model diinisialisasi** dengan jumlah pengguna dan ponsel unik, menggunakan embedding size 30.
  Optimizer: **Adam**, Loss: **Binary Crossentropy**, Metrik: **RMSE**.
"""

# Atur EarlyStopping
early_stop = EarlyStopping(
    monitor='val_root_mean_squared_error',
    patience=10,
    restore_best_weights=True
)

"""
* **EarlyStopping** digunakan untuk menghentikan pelatihan jika tidak ada peningkatan RMSE validasi selama 10 epoch.
  Parameter: `monitor='val_root_mean_squared_error'`, `patience=10`, `restore_best_weights=True`.
"""

# Latih model
history = model.fit(
    x=x_train,
    y=y_train,
    batch_size=8,
    epochs=100,
    validation_data=(x_val, y_val),
    callbacks=[early_stop],
    verbose=1
)

"""* **Model dilatih** hingga 100 epoch dengan batch size 8, menggunakan data validasi dan callback EarlyStopping.

# Evaluation
"""

# Evaluasi data training
y_train_pred = model.predict(x_train).flatten()
rmse_train = np.sqrt(mean_squared_error(y_train, y_train_pred))

# Evaluasi data validasi
y_val_pred = model.predict(x_val).flatten()
rmse_val = np.sqrt(mean_squared_error(y_val, y_val_pred))

print(f"RMSE Train     : {rmse_train:.4f}")
print(f"RMSE Validation: {rmse_val:.4f}")

# Visualisasi RMSE
plt.plot(history.history['root_mean_squared_error'], label='Train RMSE')
plt.plot(history.history['val_root_mean_squared_error'], label='Val RMSE')
plt.title('Model Performance')
plt.xlabel('Epoch')
plt.ylabel('RMSE')
plt.legend()
plt.grid(True)
plt.show()

# Load ulang rating dan salin data ponsel
df_rating = pd.read_csv('cellphones ratings.csv')
phone_df = df_phones.copy()

def recommend_for_user(user_id, top_n=10):
    # Mengecek apakah user ID valid
    if user_id not in user_to_user_encoded:
        print("User ID tidak ditemukan dalam data.")
        return

    # Mengambil ponsel yang sudah direview oleh user
    cellphone_reviewed_by_user = df_rating[df_rating['user_id'] == user_id]

    # Memfilter ponsel yang belum direview
    cellphone_not_reviewed = phone_df[~phone_df['cellphone_id'].isin(cellphone_reviewed_by_user['cellphone_id'].values)]
    cellphone_not_reviewed = cellphone_not_reviewed[cellphone_not_reviewed['cellphone_id'].isin(cellphone_to_cellphone_encoded)]

    # Encode user dan ponsel untuk input ke model
    cellphone_not_reviewed_encoded = [[cellphone_to_cellphone_encoded.get(x)] for x in cellphone_not_reviewed['cellphone_id']]
    user_encoded = user_to_user_encoded.get(user_id)
    user_cellphone_array = np.hstack(([[user_encoded]] * len(cellphone_not_reviewed_encoded), cellphone_not_reviewed_encoded))

    # Memprediksi rating ponsel yang belum direview
    ratings = model.predict(user_cellphone_array).flatten()
    predicted_ratings = ratings * (max_rating - min_rating) + min_rating  # Konversi dari sigmoid ke skala rating asli

    # Mengambil indeks ponsel dengan prediksi tertinggi
    top_ratings_indices = predicted_ratings.argsort()[-top_n:][::-1]
    recommended_cellphone_ids = [cellphone_encoded_to_cellphone.get(cellphone_not_reviewed_encoded[x][0]) for x in top_ratings_indices]

    # Menampilkan ponsel yang paling disukai user
    print(f"\nRekomendasi untuk pengguna: {user_id}")
    print("=" * 40)
    print("Ponsel dengan rating tertinggi oleh pengguna ini:")
    print("-" * 40)
    top_cellphones = (
        cellphone_reviewed_by_user.sort_values(by='rating', ascending=False)
        .head(5)['cellphone_id'].values
    )
    top_reviewed = phone_df[phone_df['cellphone_id'].isin(top_cellphones)]
    for row in top_reviewed.itertuples():
        print(f"{row.brand} : {row.model}")

    # Menampilkan rekomendasi ponsel
    print("-" * 40)
    print(f"Top {top_n} Rekomendasi Ponsel:")
    print("-" * 40)
    recommended_phones = phone_df[phone_df['cellphone_id'].isin(recommended_cellphone_ids)]
    for row in recommended_phones.itertuples():
        print(f"{row.brand} : {row.model}")

recommend_for_user(user_id=1, top_n=10)